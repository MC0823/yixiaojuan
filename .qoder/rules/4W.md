---
trigger: manual
---
# 代码污染耦合规则

# 第一章 总则

## 1.1 文档目的

为规范各类软件开发过程中的代码编写行为，从根源上解决代码耦合过高、全局变量污染两大核心技术痛点，降低后期功能迭代难度、减少线上故障发生率，保障项目代码的可维护性、可扩展性与稳定性，特制定本专项约束文档。本文档适用于后端服务、前端应用、移动开发等全类型软件项目，所有参与项目的开发人员及AI编程协作过程均需严格遵循。

## 1.2 核心定义

- **代码耦合**：指不同类、模块或系统之间存在过度依赖关系，一方的修改会导致另一方或多方必须随之调整，具体表现为直接操作其他类私有变量、硬编码引用外部模块、无隔离的跨模块调用等，分为紧密耦合、内容耦合、公共耦合等类型。

- **全局污染**：指未经过封装的全局变量、静态变量被随意定义和修改，或公共命名空间被滥用，导致数据流向混乱、修改来源无法追踪，进而引发数据一致性问题、功能冲突及命名冲突的现象。

- **UI污染**：指在用户界面开发中，由于弹窗状态管理混乱、样式作用域泄漏、事件监听器未正确清理等导致的界面交互冲突、内存泄漏和样式污染现象。

- **适用范围**：本文档约束覆盖软件开发中的类/组件设计、模块通信、数据管理、架构搭建、跨模块交互、UI组件开发等所有涉及代码耦合与数据存储的环节，包括新功能开发、现有代码重构、bug修复等场景。

## 1.3 文档使用说明

本文档为开发过程中的"代码规范准则"，开发人员在编写新代码、修改现有代码及与AI编程助手协作时，需随时对照文档约束执行。可将文档核心规则整合至IDE代码检查插件，或在代码评审流程中作为必查依据，确保约束落地。

**工具集成建议**：
- 后端Java项目：配置Checkstyle、PMD、SonarQube等静态分析工具
- 前端项目：配置ESLint、Prettier、Stylelint，启用no-restricted-globals等规则
- 移动端：配置Android Lint、Detekt（Kotlin）
- CI/CD流程：在代码合并前强制执行静态检查

# 第二章 代码耦合专项约束

## 2.1 耦合控制核心原则

所有代码编写必须严格遵循"单一职责原则""最小知识原则"与"依赖倒置原则"，确保类/组件与类/组件、模块与模块之间仅保持必要的交互边界，不暴露内部实现细节，不承担超出自身职责的功能，通过抽象接口隔离依赖，从设计层面降低耦合度。

## 2.2 类/组件设计耦合约束

### 2.2.1 职责边界清晰化

每个类/组件必须仅承担一项核心职责，命名需精准反映其职责范围（如"UserManager"仅负责用户信息管理，"OrderValidator"仅负责订单数据校验），严禁设计"万能工具类""全能管理器"等职责模糊的模块，避免因职责混杂导致的耦合扩散。

**正确示例（Java）**：
```java
// 仅负责用户信息管理的类
public class UserManager {
    private final UserRepository userRepository;
    private final Logger logger = LoggerFactory.getLogger(UserManager.class);
    
    public UserManager(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    public User register(User user) {
        try {
            // 业务逻辑
            return userRepository.save(user);
        } catch (Exception e) {
            logger.error("用户注册失败: {}", user.getUsername(), e);
            throw new BusinessException("用户注册失败");
        }
    }
}
```

**错误示例（Java）**：
```java
// 职责模糊，包含用户、订单、支付等多种功能
public class BusinessUtil {
    public void registerUser(User user) { /* 实现逻辑 */ }
    public boolean checkOrder(Order order) { /* 实现逻辑 */ }
    public void handlePayCallback(String callbackData) { /* 实现逻辑 */ }
}
```

### 2.2.2 访问权限严格管控

必须合理使用访问修饰符（private、protected、public、default等），将类/组件的内部数据与非必要方法设为私有，仅通过公开的受控接口（如getter/setter、业务方法）对外提供服务，禁止外部模块直接访问或修改私有成员，切断不必要的依赖链路。

**正确示例（TypeScript）**：
```typescript
export class ProductService {
    // 私有数据：外部无法直接访问
    private productList: Product[] = [];
    private readonly logger: Logger;
    
    constructor(logger: Logger) {
        this.logger = logger;
    }
    
    // 公开接口：受控的商品添加方法
    public addProduct(product: Product): void {
        if (!product.id || !product.name) {
            throw new Error("商品ID和名称为必填项");
        }
        this.productList.push(product);
        this.notifyProductChange();
        this.logger.info(`商品添加成功: ${product.id}`);
    }
    
    // 私有方法：内部逻辑，不对外暴露
    private notifyProductChange(): void {
        // 发送商品变化通知
    }
}
```

## 2.3 模块通信耦合约束

### 2.3.1 强制采用松耦合通信方式

所有跨模块、跨类的通信必须采用事件驱动、发布-订阅（Pub/Sub）、依赖注入（DI）等松耦合方式，禁止直接引用具体实现类。

**正确示例（Java/Spring事件驱动）**：
```java
// 订单服务发布事件
@Service
public class OrderService {
    private final ApplicationEventPublisher eventPublisher;
    private final Logger logger;
    
    public void createOrder(Order order) {
        // 订单创建逻辑
        Long orderId = this.saveOrder(order);
        
        // 发布事件，不关心谁接收
        eventPublisher.publishEvent(new OrderCreatedEvent(orderId));
        logger.info("订单创建事件已发布: {}", orderId);
    }
}

// 库存服务监听事件
@Service
public class InventoryService {
    @EventListener
    @Async  // 异步处理，避免阻塞主流程
    public void handleOrderCreated(OrderCreatedEvent event) {
        try {
            this.deductInventory(event.getOrderId());
        } catch (Exception e) {
            logger.error("库存扣减失败: {}", event.getOrderId(), e);
            // 发送告警或重试逻辑
        }
    }
}
```

### 2.3.2 禁止硬编码依赖与直接引用

严禁在代码中通过类名直接实例化外部模块对象，所有依赖必须通过配置文件、依赖注入框架或服务发现机制获取。

**正确示例（Python/依赖注入）**：
```python
from abc import ABC, abstractmethod
import logging

class UserServiceInterface(ABC):
    @abstractmethod
    def get_user(self, user_id: int) -> User:
        pass

class OrderService:
    def __init__(self, user_service: UserServiceInterface, logger: logging.Logger):
        self.user_service = user_service
        self.logger = logger
    
    def create_order(self, user_id: int, goods: List[Goods]) -> Order:
        try:
            user = self.user_service.get_user(user_id)
            if not user:
                raise ValueError("用户不存在")
            # 订单创建逻辑
            self.logger.info(f"订单创建成功: user_id={user_id}")
            return order
        except Exception as e:
            self.logger.error(f"订单创建失败: {e}")
            raise
```

## 2.4 架构层面耦合约束

### 2.4.1 严格遵循分层架构规范

所有软件项目必须采用清晰的分层架构，各层之间仅允许单向依赖，禁止跨层调用或反向依赖。

**正确示例（后端分层架构/Java）**：
```java
// 业务逻辑层：包含完整的异常处理和日志记录
@Service
@Transactional
public class OrderService {
    private final OrderRepository orderRepository;
    private final InventoryService inventoryService;
    private final Logger logger;
    
    public Order createOrder(OrderCreateDTO dto) {
        logger.info("开始创建订单: {}", dto);
        
        // 1. 业务校验
        if (dto.getAmount().compareTo(BigDecimal.ZERO) <= 0) {
            logger.warn("订单金额异常: {}", dto.getAmount());
            throw new IllegalArgumentException("订单金额必须大于0");
        }
        
        // 2. 调用其他服务
        boolean stockEnough = inventoryService.checkStock(dto.getGoodsId(), dto.getQuantity());
        if (!stockEnough) {
            logger.warn("商品库存不足: goodsId={}", dto.getGoodsId());
            throw new BusinessException("商品库存不足");
        }
        
        // 3. 执行业务逻辑
        Order order = convertToEntity(dto);
        Order savedOrder = orderRepository.save(order);
        
        logger.info("订单创建成功: orderId={}", savedOrder.getId());
        return savedOrder;
    }
}
```

# 第三章 代码结构与文件夹组织约束

## 3.1 通用约束原则

代码结构与文件夹组织需遵循"高内聚、低耦合""约定优于配置""清晰可追溯"三大原则，确保团队成员能快速定位文件位置，新增文件时明确存放路径。

## 3.2 代码结构约束

### 3.2.1 后端服务代码结构

后端代码需按"分层+模块"双重维度组织，强化异常处理和日志记录。

**正确示例（Java Service结构）**：
```java
@Service
@Slf4j  // 使用Lombok简化日志声明
public class OrderServiceImpl implements OrderService {
    private final OrderRepository orderRepo;
    private final InventoryService inventoryService;
    private final EventPublisher eventPublisher;
    
    @Override
    @Transactional
    public Order createOrder(OrderCreateDTO dto) {
        try {
            // 参数校验
            validateOrderDTO(dto);
            
            // 业务逻辑
            Order order = buildOrderEntity(dto);
            Order savedOrder = orderRepo.save(order);
            
            // 发布领域事件
            eventPublisher.publish(new OrderCreatedEvent(savedOrder.getId()));
            
            log.info("订单创建成功: orderId={}, userId={}", savedOrder.getId(), dto.getUserId());
            return savedOrder;
            
        } catch (ConstraintViolationException e) {
            log.warn("订单参数校验失败: {}", dto, e);
            throw new BusinessException("订单参数不合法");
        } catch (DataAccessException e) {
            log.error("订单数据保存失败: {}", dto, e);
            throw new BusinessException("订单保存失败");
        }
    }
    
    private void validateOrderDTO(OrderCreateDTO dto) {
        // 详细的参数校验逻辑
    }
}
```

# 第四章 全局污染专项约束

## 4.1 全局污染控制核心原则

所有数据与命名空间必须遵循"封装保护、受控访问、可追溯"原则，严禁定义无封装的全局变量、静态变量及全局函数。

## 4.2 变量与函数污染约束

### 4.2.1 严禁无封装全局变量

所有需要跨模块共享的数据必须封装到专门的管理类/服务中，通过受控接口对外提供访问与修改服务。

**正确示例（TypeScript/状态管理）**：
```typescript
class UserStateService {
    private static instance: UserStateService;
    private user: User | null = null;
    private listeners: Array<(user: User | null) => void> = [];
    
    private constructor() {}
    
    public static getInstance(): UserStateService {
        if (!UserStateService.instance) {
            UserStateService.instance = new UserStateService();
        }
        return UserStateService.instance;
    }
    
    public setUser(user: User): void {
        if (!user.id) {
            throw new Error("用户ID不能为空");
        }
        this.user = user;
        this.notifyListeners();
        console.log(`用户状态更新: ${user.username}`);
    }
    
    public getUser(): User | null {
        return this.user;
    }
    
    public clearUser(): void {
        this.user = null;
        this.notifyListeners();
        console.log("用户状态已清除");
    }
    
    public subscribe(listener: (user: User | null) => void): void {
        this.listeners.push(listener);
    }
    
    private notifyListeners(): void {
        this.listeners.forEach(listener => listener(this.user));
    }
}
```

### 4.2.2 禁止滥用静态方法与单例

静态方法仅允许用于无状态工具类，单例模式需通过私有构造器+懒加载实现，且包含完整的异常处理。

**正确示例（Java/工具类）**：
```java
@Slf4j
public final class DateUtils {
    private DateUtils() {
        throw new UnsupportedOperationException("工具类不允许实例化");
    }
    
    public static String formatIsoDate(Date date) {
        if (date == null) {
            log.warn("日期参数为空，返回空字符串");
            return "";
        }
        
        try {
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");
            sdf.setTimeZone(TimeZone.getTimeZone("UTC"));
            return sdf.format(date);
        } catch (Exception e) {
            log.error("日期格式化失败: {}", date, e);
            return "";
        }
    }
}
```

## 4.3 命名空间污染约束

### 4.3.1 前端命名空间管控

JavaScript/TypeScript项目必须使用ES6 Module规范，避免全局命名冲突。

**正确示例（TypeScript/模块化）**：
```typescript
// date-util.ts
export function formatDate(date: Date, format: string = 'YYYY-MM-DD'): string {
    if (!(date instanceof Date)) {
        throw new Error("参数必须为Date类型");
    }
    
    try {
        // 实现日期格式化逻辑
        return formattedDate;
    } catch (error) {
        console.error('日期格式化失败:', error);
        return '';
    }
}

// 使用方
import { formatDate } from './utils/date-util';
const today = formatDate(new Date());
```

## 4.4 数据持久化污染约束

### 4.4.1 数据库操作约束

数据库操作必须通过ORM框架实现，包含完整的数据校验和异常处理。

**正确示例（Java/Spring Data JPA）**：
```java
@Repository
@Slf4j
public class OrderRepositoryImpl implements OrderRepositoryCustom {
    private final EntityManager entityManager;
    
    @Override
    @Transactional
    public Order saveWithValidation(Order order) {
        try {
            // 数据校验
            if (order.getAmount() == null || order.getAmount().compareTo(BigDecimal.ZERO) <= 0) {
                log.warn("订单金额异常: {}", order.getAmount());
                throw new ValidationException("订单金额必须大于0");
            }
            
            if (order.getId() == null) {
                entityManager.persist(order);
                log.info("新增订单: {}", order.getId());
            } else {
                order = entityManager.merge(order);
                log.info("更新订单: {}", order.getId());
            }
            
            return order;
            
        } catch (PersistenceException e) {
            log.error("订单保存失败: {}", order, e);
            throw new DataAccessException("订单保存失败", e);
        }
    }
}
```

### 4.4.2 缓存操作约束

缓存键名需遵循命名规范，包含序列化和敏感信息处理。

**正确示例（Java/Redis缓存）**：
```java
@Service
@Slf4j
public class UserCacheService {
    private static final String CACHE_PREFIX = "project:user:";
    private static final Duration DEFAULT_TTL = Duration.ofHours(1);
    
    private final RedisTemplate<String, Object> redisTemplate;
    private final ObjectMapper objectMapper;
    
    public void cacheUser(User user) {
        try {
            // 脱敏处理
            UserCacheDTO cacheDTO = UserCacheDTO.fromEntity(user);
            cacheDTO.maskSensitiveInfo();
            
            String key = CACHE_PREFIX + user.getId();
            String value = objectMapper.writeValueAsString(cacheDTO);
            
            redisTemplate.opsForValue().set(key, value, DEFAULT_TTL);
            log.debug("用户缓存成功: userId={}", user.getId());
            
        } catch (JsonProcessingException e) {
            log.error("用户序列化失败: {}", user.getId(), e);
        } catch (Exception e) {
            log.error("缓存写入失败: {}", user.getId(), e);
        }
    }
}
```

# 第五章 UI污染专项约束

## 5.1 UI污染控制核心原则

所有UI组件必须遵循"职责单一、状态隔离、生命周期可控"原则，严禁创建全局共享的UI状态、避免弹窗叠加污染、防止样式冲突扩散。

## 5.2 弹窗污染约束

### 5.2.1 弹窗状态集中管理

弹窗的显示/隐藏状态必须通过统一的状态管理机制控制，禁止在多个组件中分散管理弹窗状态。

**正确示例（React + Zustand）**：
```typescript
// 弹窗状态管理
interface ModalState {
  // 弹窗状态映射
  modals: Record<string, boolean>;
  // 打开弹窗
  openModal: (modalId: string) => void;
  // 关闭弹窗
  closeModal: (modalId: string) => void;
  // 关闭所有弹窗
  closeAllModals: () => void;
}

export const useModalStore = create<ModalState>((set) => ({
  modals: {},
  openModal: (modalId: string) => 
    set((state) => ({
      modals: { ...state.modals, [modalId]: true }
    })),
  closeModal: (modalId: string) =>
    set((state) => ({
      modals: { ...state.modals, [modalId]: false }
    })),
  closeAllModals: () =>
    set({ modals: {} })
}));

// 弹窗容器组件
export const ModalContainer: React.FC = () => {
  const { modals, closeModal } = useModalStore();
  
  return (
    <>
      {Object.entries(modals).map(([modalId, isOpen]) => (
        isOpen && (
          <Modal
            key={modalId}
            open={isOpen}
            onClose={() => closeModal(modalId)}
            className={`modal-${modalId}`}
          >
            {/* 弹窗内容 */}
          </Modal>
        )
      ))}
    </>
  );
};
```

### 5.2.2 弹窗层级与叠加控制

必须严格控制弹窗的z-index层级，防止弹窗叠加导致的交互混乱。

**正确示例（CSS-in-JS）**：
```typescript
// 弹窗层级管理
const modalZIndex = {
  backdrop: 1000,
  normal: 1001,
  important: 1002,
  emergency: 1003,
} as const;

const ModalBackdrop = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  z-index: ${modalZIndex.backdrop};
`;

const ModalContent = styled.div<{ priority: keyof typeof modalZIndex }>`
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: ${props => modalZIndex[props.priority]};
  background: white;
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
  max-width: 90vw;
  max-height: 90vh;
  overflow: auto;
`;

// 使用示例
export const AlertModal: React.FC<AlertModalProps> = ({ 
  open, 
  onClose, 
  priority = 'normal',
  children 
}) => {
  if (!open) return null;
  
  return (
    <>
      <ModalBackdrop onClick={onClose} />
      <ModalContent priority={priority}>
        {children}
      </ModalContent>
    </>
  );
};
```

### 5.2.3 弹窗生命周期管理

弹窗组件必须具备完整的生命周期管理，包括打开、关闭、销毁等状态。

**正确示例（Vue3 Composition API）**：
```typescript
// 弹窗组合式函数
export function useModalLifecycle() {
  const isOpen = ref(false);
  const isMounted = ref(false);
  
  const open = () => {
    isMounted.value = true;
    // 下一帧打开，确保DOM已挂载
    nextTick(() => {
      isOpen.value = true;
    });
  };
  
  const close = () => {
    isOpen.value = false;
    // 等待关闭动画完成后再销毁
    setTimeout(() => {
      isMounted.value = false;
    }, 300);
  };
  
  // 自动清理
  onUnmounted(() => {
    isOpen.value = false;
    isMounted.value = false;
  });
  
  return {
    isOpen: readonly(isOpen),
    isMounted: readonly(isMounted),
    open,
    close
  };
}

// 使用示例
export default defineComponent({
  setup() {
    const modal = useModalLifecycle();
    
    // 阻止背景滚动
    watch(modal.isOpen, (open) => {
      if (open) {
        document.body.style.overflow = 'hidden';
      } else {
        document.body.style.overflow = '';
      }
    });
    
    return { ...modal };
  }
});
```

## 5.3 全局UI状态污染约束

### 5.3.1 全局样式污染防护

CSS/样式文件必须采用作用域隔离，防止全局样式污染。

**正确示例（CSS Modules）**：
```css
/* Modal.module.css */
.modal {
  composes: base-modal from './base.css'; /* 组合基础样式 */
  position: fixed;
  z-index: 1000;
}

.backdrop {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
}

/* 使用BEM命名规范防止冲突 */
.modal--important {
  z-index: 1002;
}

.modal__header {
  padding: 16px;
  border-bottom: 1px solid #e0e0e0;
}

.modal__content {
  padding: 16px;
}
```

**正确示例（Styled Components）**：
```typescript
// 样式组件隔离
export const StyledModal = styled.div`
  /* 所有样式都在组件作用域内 */
  position: fixed;
  z-index: ${({ theme }) => theme.zIndex.modal};
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  
  /* 使用主题变量避免硬编码 */
  background: ${({ theme }) => theme.colors.background};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  box-shadow: ${({ theme }) => theme.shadows.large};
  
  /* 防止样式泄漏到外部 */
  && {
    /* 重置可能影响外部的样式 */
    all: initial;
    box-sizing: border-box;
  }
  
  /* 子元素样式隔离 */
  .modal-content {
    padding: 20px;
  }
  
  .modal-actions {
    display: flex;
    justify-content: flex-end;
    gap: 8px;
    padding: 16px;
    border-top: 1px solid ${({ theme }) => theme.colors.border};
  }
`;
```

### 5.3.2 全局事件监听器污染防护

事件监听器必须正确绑定和解绑，防止内存泄漏和事件重复触发。

**正确示例（React Hook）**：
```typescript
export const useGlobalEventListener = <K extends keyof WindowEventMap>(
  eventType: K,
  handler: (event: WindowEventMap[K]) => void,
  options?: boolean | AddEventListenerOptions
) => {
  const savedHandler = useRef(handler);
  
  // 更新handler引用
  useEffect(() => {
    savedHandler.current = handler;
  }, [handler]);
  
  useEffect(() => {
    const eventListener = (event: WindowEventMap[K]) => {
      savedHandler.current(event);
    };
    
    window.addEventListener(eventType, eventListener, options);
    
    // 清理函数
    return () => {
      window.removeEventListener(eventType, eventListener, options);
    };
  }, [eventType, options]);
};

// 使用示例
export const EscapeHandler: React.FC<{ onEscape: () => void }> = ({ onEscape }) => {
  useGlobalEventListener('keydown', (event) => {
    if (event.key === 'Escape') {
      onEscape();
    }
  });
  
  return null; // 无UI渲染
};
```

## 5.4 UI组件通信污染约束

### 5.4.1 组件间通信规范

UI组件间通信必须通过props、事件总线或状态管理，禁止直接操作DOM或组件实例。

**正确示例（Vue3 + Provide/Inject）**：
```typescript
// 提供弹窗上下文
export const ModalSymbol = Symbol('modal');

export interface ModalContext {
  openModal: (id: string) => void;
  closeModal: (id: string) => void;
  activeModal: string | null;
}

export const useModalProvider = () => {
  const activeModal = ref<string | null>(null);
  
  const openModal = (id: string) => {
    // 关闭当前弹窗再打开新的
    if (activeModal.value) {
      closeModal(activeModal.value);
    }
    activeModal.value = id;
  };
  
  const closeModal = (id: string) => {
    if (activeModal.value === id) {
      activeModal.value = null;
    }
  };
  
  provide(ModalSymbol, {
    openModal,
    closeModal,
    activeModal: readonly(activeModal)
  });
};

// 注入使用
export const useModal = () => {
  const context = inject<ModalContext>(ModalSymbol);
  
  if (!context) {
    throw new Error('useModal must be used within ModalProvider');
  }
  
  return context;
};
```

# 第六章 测试代码约束

## 6.1 测试代码耦合约束

测试代码同样需要遵循低耦合原则，避免测试之间的依赖和污染。

### 6.1.1 测试隔离原则

每个测试用例必须独立运行，不依赖其他测试的状态，测试完成后需要清理测试数据。

**正确示例（Java/Spring Boot Test）**：
```java
@SpringBootTest
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@Transactional
public class OrderServiceTest {
    @Autowired
    private OrderService orderService;
    
    @Autowired
    private TestEntityManager testEntityManager;
    
    @AfterEach
    void tearDown() {
        // 清理测试数据
        testEntityManager.clear();
    }
    
    @Test
    void createOrder_WithValidData_ShouldSuccess() {
        // Given
        OrderCreateDTO dto = createValidOrderDTO();
        
        // When
        Order result = orderService.createOrder(dto);
        
        // Then
        assertNotNull(result.getId());
        assertEquals(OrderStatus.CREATED, result.getStatus());
    }
    
    @Test
    void createOrder_WithInvalidAmount_ShouldThrowException() {
        // Given
        OrderCreateDTO dto = createOrderDTOWithInvalidAmount();
        
        // When & Then
        assertThrows(BusinessException.class, () -> orderService.createOrder(dto));
    }
}
```

### 6.1.2 测试数据管理

测试数据应该通过Builder模式或Object Mother模式创建，避免硬编码和重复。

**正确示例（Java/测试数据构建）**：
```java
class OrderTestDataBuilder {
    private Long id;
    private BigDecimal amount = new BigDecimal("100.00");
    private Long userId = 1L;
    private OrderStatus status = OrderStatus.CREATED;
    
    public static OrderTestDataBuilder anOrder() {
        return new OrderTestDataBuilder();
    }
    
    public OrderTestDataBuilder withAmount(BigDecimal amount) {
        this.amount = amount;
        return this;
    }
    
    public OrderTestDataBuilder withUserId(Long userId) {
        this.userId = userId;
        return this;
    }
    
    public Order build() {
        Order order = new Order();
        order.setId(id);
        order.setAmount(amount);
        order.setUserId(userId);
        order.setStatus(status);
        return order;
    }
}

// 使用方式
Order validOrder = OrderTestDataBuilder.anOrder().withAmount(new BigDecimal("200.00")).build();
Order invalidOrder = OrderTestDataBuilder.anOrder().withAmount(BigDecimal.ZERO).build();
```

## 6.2 测试全局污染约束

### 6.2.1 测试环境隔离

测试环境必须与开发、生产环境隔离，测试配置独立管理。

**正确示例（Spring测试配置）**：
```java
@TestConfiguration
public class TestConfig {
    @Bean
    @Primary
    public UserService mockUserService() {
        UserService mock = mock(UserService.class);
        when(mock.getUser(anyLong())).thenReturn(createTestUser());
        return mock;
    }
    
    @Bean
    @Primary
    public CacheManager testCacheManager() {
        return new ConcurrentMapCacheManager("test-cache");
    }
}
```

### 6.2.2 UI组件测试约束

UI组件测试必须验证弹窗状态隔离和清理。

**正确示例（React Testing Library）**：
```typescript
describe('Modal Component', () => {
  afterEach(() => {
    // 确保每个测试后清理所有弹窗
    cleanup();
    // 重置状态管理
    useModalStore.setState({ modals: {} });
  });
  
  test('should close modal when backdrop is clicked', async () => {
    const { getByTestId, queryByRole } = render(
      <ModalContainer>
        <TestComponent />
      </ModalContainer>
    );
    
    // 打开弹窗
    fireEvent.click(getByTestId('open-modal-button'));
    
    // 验证弹窗存在
    expect(queryByRole('dialog')).toBeInTheDocument();
    
    // 点击背景关闭
    fireEvent.click(getByTestId('modal-backdrop'));
    
    // 验证弹窗已关闭
    expect(queryByRole('dialog')).not.toBeInTheDocument();
  });
  
  test('should not have multiple modals open simultaneously', () => {
    const { getByTestId, getAllByRole } = render(
      <ModalContainer>
        <TestComponent />
      </ModalContainer>
    );
    
    // 尝试打开多个弹窗
    fireEvent.click(getByTestId('open-modal-1'));
    fireEvent.click(getByTestId('open-modal-2'));
    
    // 验证只有一个弹窗打开
    expect(getAllByRole('dialog')).toHaveLength(1);
  });
});
```

# 第七章 工具与自动化支持

## 7.1 静态代码分析配置

### 7.1.1 Java项目配置示例

**Checkstyle配置**：
```xml
<!-- checkstyle.xml -->
<module name="Checker">
    <module name="TreeWalker">
        <module name="AvoidStaticImport"/>
        <module name="IllegalImport">
            <property name="illegalPkgs" value="sun, com.sun"/>
        </module>
        <module name="RedundantModifier"/>
    </module>
</module>
```

### 7.1.2 前端项目配置示例

**ESLint配置**：
```javascript
// .eslintrc.js
module.exports = {
    rules: {
        'no-restricted-globals': ['error', 'event', 'name', 'length'],
        'no-implicit-globals': 'error',
        'no-unused-vars': ['error', { vars: 'all', args: 'after-used' }],
        // 禁止直接操作DOM
        'no-restricted-syntax': [
            'error',
            {
                selector: 'MemberExpression[object.name="document"][property.name="getElementById"]',
                message: '请使用React ref或Vue template ref代替直接DOM操作'
            }
        ],
        // 强制组件props校验
        'react/require-default-props': ['error']
    }
};
```

**Stylelint样式隔离配置**：
```javascript
// .stylelintrc.js
module.exports = {
  rules: {
    // 禁止使用全局选择器
    'selector-max-universal': 0,
    // 强制使用命名空间
    'selector-nested-pattern': '^&',
    // 禁止使用ID选择器
    'selector-max-id': 0
  }
};
```

## 7.2 CI/CD集成

在CI/CD流水线中集成代码质量检查：

```yaml
# .github/workflows/quality-check.yml
name: Code Quality Check
on: [push, pull_request]

jobs:
  quality:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Static Analysis
        run: |
          mvn checkstyle:check
          npm run lint
          npm run stylelint
          ./gradlew detekt
      - name: Tests
        run: |
          mvn test
          npm test
          npm run test:ui
```

## 7.3 UI专项检查工具

### 7.3.1 弹窗污染检测脚本

```javascript
// scripts/check-modal-pollution.js
const fs = require('fs');
const path = require('path');

// 检查文件中是否存在全局弹窗状态管理
function checkModalPollution(filePath) {
  const content = fs.readFileSync(filePath, 'utf8');
  
  // 检测不规范的弹窗状态管理
  const antiPatterns = [
    /document\.body\.appendChild\(.*[Mm]odal/,
    /window\.modal/,
    /globalThis\.modal/,
    /var\s+modal.*=.*document\.createElement/
  ];
  
  const issues = [];
  antiPatterns.forEach((pattern, index) => {
    if (pattern.test(content)) {
      issues.push(`检测到弹窗污染模式: ${pattern}`);
    }
  });
  
  return issues;
}

// 扫描项目文件
function scanProject(directory) {
  const results = [];
  
  function scan(dir) {
    const files = fs.readdirSync(dir);
    
    files.forEach(file => {
      const fullPath = path.join(dir, file);
      const stat = fs.statSync(fullPath);
      
      if (stat.isDirectory() && !file.includes('node_modules')) {
        scan(fullPath);
      } else if (file.match(/\.(js|jsx|ts|tsx|vue)$/)) {
        const issues = checkModalPollution(fullPath);
        if (issues.length > 0) {
          results.push({
            file: fullPath,
            issues
          });
        }
      }
    });
  }
  
  scan(directory);
  return results;
}

// 执行检查
const issues = scanProject('./src');
if (issues.length > 0) {
  console.error('发现UI污染问题:');
  issues.forEach(({ file, issues }) => {
    console.error(`\n${file}:`);
    issues.forEach(issue => console.error(`  - ${issue}`));
  });
  process.exit(1);
} else {
  console.log('✅ 未发现UI污染问题');
}
```